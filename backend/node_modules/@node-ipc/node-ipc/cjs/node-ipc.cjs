'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var os = require('os');
var net = require('net');
var tls = require('tls');
var fs = require('fs');
var dgram = require('dgram');
var util = require('util');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var os__default = /*#__PURE__*/_interopDefaultLegacy(os);
var net__default = /*#__PURE__*/_interopDefaultLegacy(net);
var tls__default = /*#__PURE__*/_interopDefaultLegacy(tls);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var dgram__default = /*#__PURE__*/_interopDefaultLegacy(dgram);
var util__default = /*#__PURE__*/_interopDefaultLegacy(util);

class Defaults {
    constructor() {
        this.appspace = "app.";
        this.socketRoot = "/tmp/";
        this.id = os__default["default"].hostname();
        this.encoding = "utf8";
        this.rawBuffer = false;
        this.sync = false;
        this.unlink = true;
        this.delimiter = "\f";
        this.silent = false;
        this.logDepth = 5;
        this.logInColor = true;
        this.logger = console.log.bind(console);
        this.maxConnections = 100;
        this.retry = 500;
        this.maxRetries = Infinity;
        this.stopRetrying = false;
        this.IPType = getIPType();
        this.tls = false;
        this.networkHost = this.IPType == "IPv6" ? "::1" : "127.0.0.1";
        this.networkPort = 8000;
        this.readableAll = false;
        this.writableAll = false;
        this.interface = {
            localAddress: false,
            localPort: false,
            family: false,
            hints: false,
            lookup: false,
        };
    }
}
function getIPType() {
    const networkInterfaces = os__default["default"].networkInterfaces();
    let IPType = "";
    if (networkInterfaces &&
        Array.isArray(networkInterfaces) &&
        networkInterfaces.length > 0) {
        // getting the family of first network interface available
        IPType = networkInterfaces[Object.keys(networkInterfaces)[0]][0].family;
    }
    return IPType;
}

class Parser {
    constructor(config) {
        if (!config) {
            config = new Defaults();
        }
        this.delimiter = config.delimiter ?? "\f";
    }
    format(message) {
        if (!message.data && message.data !== false && message.data !== 0) {
            message.data = {};
        }
        if (message.data["_maxListeners"]) {
            message.data = {};
        }
        message = message.JSON + this.delimiter;
        return message;
    }
    parse(data) {
        let events = data.split(this.delimiter);
        events.pop();
        return events;
    }
}

function Message() {
    Object.defineProperties(
        this, {
            data: {
                enumerable: true,
                get: getData,
                set: setData
            },
            type: {
                enumerable: true,
                get: getType,
                set: setType
            },
            load:{
                enumerable:true,
                writable:false,
                value:parse
            },
            JSON: {
                enumerable: true,
                get: getJSON
            }
        }
    );

    var type = '';
    var data = {};

    function getType() {
        return type;
    }

    function getData() {
        return data;
    }

    function getJSON() {
        return JSON.stringify(
            {
                type: type,
                data: data
            }
        );
    }

    function setType(value) {
        type = value;
    }

    function setData(value) {
        data = value;
    }

    function parse(message){
        try{
            var message=JSON.parse(message);
            type=message.type;
            data=message.data;
        }catch(err){
            var badMessage=message;
            type='error',
            data={
                message:'Invalid JSON response format',
                err:err,
                response:badMessage
            };
        }
    }
}

var Message_1=Message;

function Queue(asStack){
    Object.defineProperties(
        this,
        {
            add:{
                enumerable:true,
                writable:false,
                value:addToQueue
            },
            next:{
                enumerable:true,
                writable:false,
                value:run
            },
            clear:{
                enumerable:true,
                writable:false,
                value:clearQueue
            },
            contents:{
                enumerable:false,
                get:getQueue,
                set:setQueue
            },
            autoRun:{
                enumerable:true,
                writable:true,
                value:true
            },
            stop:{
                enumerable:true,
                writable:true,
                value:false
            }
        }
    );

    var queue=[];
    var running=false;

    function clearQueue(){
        queue=[];
        return queue;
    }

    function getQueue(){
        return queue;
    }

    function setQueue(val){
        queue=val;
        return queue;
    }

    function addToQueue(){
        for(var i in arguments){
            queue.push(arguments[i]);
        }
        if(!running && !this.stop && this.autoRun){
            this.next();
        }
    }

    function run(){
        running=true;
        if(queue.length<1 || this.stop){
            running=false;
            return;
        }

        queue.shift().bind(this)();
    }
}

var queue=Queue;

class Fake{
    //fake class as fallback
}

class FakeCore{
    //fake class as fallback
}

class Is{
    constructor(strict=true){
        this.strict=strict;
    }

    //core
    throw(valueType,expectedType){
        let err=new TypeError;
        err.message=`expected type of ${valueType} to be ${expectedType}`;
        if(!this.strict){
            return false;
        }
        throw err;
    }

    typeCheck(value,type){
        if(typeof value === type){
            return true;
        }
        return this.throw(typeof value,type);
    }

    instanceCheck(value=new Fake, constructor=FakeCore){
        //console.log(value,constructor);
        if(value instanceof constructor){
            return true;
        }
        return this.throw(typeof value,constructor.name);
    }

    symbolStringCheck(value,type){
        if(Object.prototype.toString.call(value) == `[object ${type}]`){
            return true;
        }
        return this.throw(Object.prototype.toString.call(value),`[object ${type}]`);
    }

    compare(value,targetValue,typeName){
        if(value==targetValue){
            return true;
        }
        
        if(!this.strict){
            return false;
        }
        throw new Error(`expected ${value} == ${targetValue} but it is not.`);
    }

    defined(value){
        const weakIs=new Is(false);
        if(weakIs.undefined(value)){
            return this.throw('undefined','defined');
        }

        return true;
    }

    any(value){
        return this.defined(value);
    }

    exists(value){
        return this.defined(value);
    }

    union(value,typesString){
        const types=typesString.split('|');
        const weakIs=new Is(false);
        let pass=false;
        let type='undefined';
        for(type of types){
            try{
                if(weakIs[type](value)){
                    pass=true;
                    break;
                }
            }catch(err){
                return this.throw(type,'a method available on strong-type');
            }
        }

        if(pass){
           return this[type](value);
        }

        return this.throw(typeof value, types.join('|'));

    }

    //unique checks
    finite(value){
        if(isFinite(value)){
            return true;
        }
        return this.throw(typeof value, 'finite');
    }

    NaN(value){
        if(!this.number(value)){
            return this.number(value);
        }

        if(isNaN(value)){
            return true;
        }

        return this.throw(typeof value, 'NaN');
    }

    null(value){
        return this.compare(value,null,'null');
    }

    //common sugar
    array(value){
        return this.instanceCheck(value,Array);
    }

    boolean(value){
        return this.typeCheck(value,'boolean');
    }

    bigInt(value){
        return this.typeCheck(value,'bigint');
    }

    date(value){
        return this.instanceCheck(value,Date);
    }

    generator(value){
        return this.symbolStringCheck(value,'Generator');
    }

    asyncGenerator(value){
        return this.symbolStringCheck(value,'AsyncGenerator');
    }

    globalThis(value){
        return this.compare(value,globalThis,'explicitly globalThis, not window, global nor self');
    }

    infinity(value){
        return this.compare(value,Infinity,'Infinity');
    }

    map(value){
        return this.instanceCheck(value,Map);
    }

    weakMap(value){
        return this.instanceCheck(value,WeakMap);
    }

    number(value){
        return this.typeCheck(value,'number');
    }

    object(value){
        return this.typeCheck(value,'object');
    }

    promise(value){
        return this.instanceCheck(value,Promise);
    }

    regExp(value){
        return this.instanceCheck(value,RegExp);
    }
    
    undefined(value){
        return this.typeCheck(value,'undefined');
    }

    set(value){
        return this.instanceCheck(value,Set);
    }

    weakSet(value){
        return this.instanceCheck(value,WeakSet);
    }
    
    string(value){
        return this.typeCheck(value,'string');
    }

    symbol(value){
        return this.typeCheck(value,'symbol');
    }

    //functions
    function(value){
        return this.typeCheck(value,'function');
    }

    asyncFunction(value){
        return this.symbolStringCheck(value,'AsyncFunction');
    }

    generatorFunction(value){
        return this.symbolStringCheck(value,'GeneratorFunction');
    }

    asyncGeneratorFunction(value){
        return this.symbolStringCheck(value,'AsyncGeneratorFunction');
    }

    //error sugar
    error(value){
        return this.instanceCheck(value,Error);
    }

    evalError(value){
        return this.instanceCheck(value,EvalError);
    }

    rangeError(value){
        return this.instanceCheck(value,RangeError);
    }

    referenceError(value){
        return this.instanceCheck(value,ReferenceError);
    }

    syntaxError(value){
        return this.instanceCheck(value,SyntaxError);
    }

    typeError(value){
        return this.instanceCheck(value,TypeError);
    }

    URIError(value){
        return this.instanceCheck(value,URIError);
    }    

    //typed array sugar
    bigInt64Array(value){
        return this.instanceCheck(value,BigInt64Array);
    }

    bigUint64Array(value){
        return this.instanceCheck(value,BigUint64Array);
    }

    float32Array(value){
        return this.instanceCheck(value,Float32Array);
    }

    float64Array(value){
        return this.instanceCheck(value,Float64Array);
    }

    int8Array(value){
        return this.instanceCheck(value,Int8Array);
    }

    int16Array(value){
        return this.instanceCheck(value,Int16Array);
    }

    int32Array(value){
        return this.instanceCheck(value,Int32Array);
    }

    uint8Array(value){
        return this.instanceCheck(value,Uint8Array);
    }

    uint8ClampedArray(value){
        return this.instanceCheck(value,Uint8ClampedArray);
    }
    
    uint16Array(value){
        return this.instanceCheck(value,Uint16Array);
    }

    uint32Array(value){
        return this.instanceCheck(value,Uint32Array);
    }

    //buffers
    arrayBuffer(value){
        return this.instanceCheck(value,ArrayBuffer);
    }

    dataView(value){
        return this.instanceCheck(value,DataView);
    }

    sharedArrayBuffer(value){
        return this.instanceCheck(value,(function(){try{return SharedArrayBuffer}catch{ return Fake}})());
    }

    //Intl (browser internationalization)
    intlDateTimeFormat(value){
        return this.instanceCheck(value,Intl.DateTimeFormat);
    }

    intlCollator(value){
        return this.instanceCheck(value,Intl.Collator);
    }

    intlDisplayNames(value){
        return this.instanceCheck(value,Intl.DisplayNames);
    }

    intlListFormat(value){
        return this.instanceCheck(value,Intl.ListFormat);
    }

    intlLocale(value){
        return this.instanceCheck(value,Intl.Locale);
    }

    intlNumberFormat(value){
        return this.instanceCheck(value,Intl.NumberFormat);
    }

    intlPluralRules(value){
        return this.instanceCheck(value,Intl.PluralRules);
    }

    intlRelativeTimeFormat(value){
        return this.instanceCheck(value,Intl.RelativeTimeFormat);
    }

    intlRelativeTimeFormat(value){
        return this.instanceCheck(value,Intl.RelativeTimeFormat);
    }



    //garbage collection
    finalizationRegistry(value){
        return this.instanceCheck(value,FinalizationRegistry);
    }

    weakRef(value){
        return this.instanceCheck(value,WeakRef);
    }
}

const is = new Is();
class EventPubSub {
  constructor() {
  }
  on(type, handler, once = false) {
    is.string(type);
    is.function(handler);
    is.boolean(once);
    if (type == "*") {
      type = this.#all;
    }
    if (!this.#events[type]) {
      this.#events[type] = [];
    }
    handler[this.#once] = once;
    this.#events[type].push(handler);
    return this;
  }
  once(type, handler) {
    return this.on(type, handler, true);
  }
  off(type = "*", handler = "*") {
    is.string(type);
    if (type == this.#all.toString() || type == "*") {
      type = this.#all;
    }
    if (!this.#events[type]) {
      return this;
    }
    if (handler == "*") {
      delete this.#events[type];
      return this;
    }
    is.function(handler);
    const handlers = this.#events[type];
    while (handlers.includes(handler)) {
      handlers.splice(handlers.indexOf(handler), 1);
    }
    if (handlers.length < 1) {
      delete this.#events[type];
    }
    return this;
  }
  emit(type, ...args) {
    is.string(type);
    const globalHandlers = this.#events[this.#all] || [];
    this.#handleOnce(this.#all.toString(), globalHandlers, type, ...args);
    if (!this.#events[type]) {
      return this;
    }
    const handlers = this.#events[type];
    this.#handleOnce(type, handlers, ...args);
    return this;
  }
  reset() {
    this.off(this.#all.toString());
    for (let type in this.#events) {
      this.off(type);
    }
    return this;
  }
  get list() {
    return Object.assign({}, this.#events);
  }
  #handleOnce = (type, handlers, ...args) => {
    is.string(type);
    is.array(handlers);
    const deleteOnceHandled = [];
    for (let handler of handlers) {
      handler(...args);
      if (handler[this.#once]) {
        deleteOnceHandled.push(handler);
      }
    }
    for (let handler of deleteOnceHandled) {
      this.off(type, handler);
    }
  };
  #all = Symbol.for("event-pubsub-all");
  #once = Symbol.for("event-pubsub-once");
  #events = {};
}

let eventParser$1 = new Parser();
class Client extends EventPubSub {
    constructor(config, log) {
        super();
        this.Client = Client;
        this.queue = new queue();
        this.socket = false;
        this.connect = connect$1;
        // @ts-expect-error We're overwriting a parent member here
        this.emit = emit$1;
        this.retriesRemaining = 0;
        this.explicitlyDisconnected = false;
        this.config = config;
        this.log = log;
        this.publish = super.emit;
        config.maxRetries ? (this.retriesRemaining = config.maxRetries) : 0;
        eventParser$1 = new Parser(this.config);
    }
}
function emit$1(type, data) {
    this.log("dispatching event to ", this.id, this.path, " : ", type, ",", data);
    let message = new Message_1();
    message.type = type;
    message.data = data;
    if (this.config.rawBuffer) {
        message = Buffer.from(type, this.config.encoding);
    }
    else {
        message = eventParser$1.format(message);
    }
    //volitile emit
    if (!this.config.sync) {
        this.socket.write(message);
        return;
    }
    //sync, non-volitile, ack emit
    this.queue.add(syncEmit.bind(this, message));
}
function syncEmit(message) {
    this.log("dispatching event to ", this.id, this.path, " : ", message);
    this.socket.write(message);
}
function connect$1() {
    //init client object for scope persistance especially inside of socket events.
    let client = this;
    client.log("requested connection to ", client.id, client.path);
    if (!this.path) {
        client.log("\n\n######\nerror: ", client.id, " client has not specified socket path it wishes to connect to.");
        return;
    }
    const options = {};
    if (!client.port) {
        client.log("Connecting client on Unix Socket :", client.path);
        options.path = client.path;
        if (process.platform === "win32" &&
            !client.path.startsWith("\\\\.\\pipe\\")) {
            options.path = options.path.replace(/^\//, "");
            options.path = options.path.replace(/\//g, "-");
            options.path = `\\\\.\\pipe\\${options.path}`;
        }
        client.socket = net__default["default"].connect(options);
    }
    else {
        options.host = client.path;
        options.port = client.port;
        if (client.config.interface.localAddress) {
            options.localAddress = client.config.interface.localAddress;
        }
        if (client.config.interface.localPort) {
            options.localPort = client.config.interface.localPort;
        }
        if (client.config.interface.family) {
            options.family = client.config.interface.family;
        }
        if (client.config.interface.hints) {
            options.hints = client.config.interface.hints;
        }
        if (client.config.interface.lookup) {
            options.lookup = client.config.interface.lookup;
        }
        if (!client.config.tls) {
            client.log("Connecting client via TCP to", options);
            client.socket = net__default["default"].connect(options);
        }
        else {
            client.log("Connecting client via TLS to", client.path, client.port, client.config.tls);
            if (client.config.tls.private) {
                client.config.tls.key = fs__default["default"].readFileSync(client.config.tls.private);
            }
            if (client.config.tls.public) {
                client.config.tls.cert = fs__default["default"].readFileSync(client.config.tls.public);
            }
            if (client.config.tls.trustedConnections) {
                if (typeof client.config.tls.trustedConnections === "string") {
                    client.config.tls.trustedConnections = [
                        client.config.tls.trustedConnections,
                    ];
                }
                client.config.tls.ca = [];
                for (let i = 0; i < client.config.tls.trustedConnections.length; i++) {
                    client.config.tls.ca.push(fs__default["default"].readFileSync(client.config.tls.trustedConnections[i]));
                }
            }
            Object.assign(client.config.tls, options);
            client.socket = tls__default["default"].connect(client.config.tls);
        }
    }
    client.socket.setEncoding(this.config.encoding);
    client.socket.on("error", function (err) {
        client.log("\n\n######\nerror: ", err);
        client.publish("error", err);
    });
    client.socket.on("connect", function connectionMade() {
        client.publish("connect");
        client.retriesRemaining = client.config.maxRetries;
        client.log("retrying reset");
    });
    client.socket.on("close", function connectionClosed() {
        client.log("connection closed", client.id, client.path, client.retriesRemaining, "tries remaining of", client.config.maxRetries);
        if (client.config.stopRetrying ||
            client.retriesRemaining < 1 ||
            client.explicitlyDisconnected) {
            client.publish("disconnect");
            client.log(client.config.id, "exceeded connection rety amount of", " or stopRetrying flag set.");
            client.socket.destroy();
            client.publish("destroy");
            client = undefined;
            return;
        }
        setTimeout(function retryTimeout() {
            if (client.explicitlyDisconnected) {
                return;
            }
            client.retriesRemaining--;
            client.connect();
        }.bind(null, client), client.config.retry);
        client.publish("disconnect");
    });
    client.socket.on("data", function (data) {
        client.log("## received events ##");
        if (client.config.rawBuffer) {
            client.publish("data", Buffer.from(data, client.config.encoding));
            if (!client.config.sync) {
                return;
            }
            client.queue.next();
            return;
        }
        if (!this.ipcBuffer) {
            this.ipcBuffer = "";
        }
        data = this.ipcBuffer += data;
        if (data.slice(-1) != eventParser$1.delimiter ||
            data.indexOf(eventParser$1.delimiter) == -1) {
            client.log("Messages are large, You may want to consider smaller messages.");
            return;
        }
        this.ipcBuffer = "";
        const events = eventParser$1.parse(data);
        const eCount = events.length;
        for (let i = 0; i < eCount; i++) {
            let message = new Message_1();
            message.load(events[i]);
            client.log("detected event", message.type, message.data);
            client.publish(message.type, message.data);
        }
        if (!client.config.sync) {
            return;
        }
        client.queue.next();
    });
}

let eventParser = new Parser();
class Server extends EventPubSub {
    constructor(path, config, log, port) {
        super();
        this.udp4 = false;
        this.udp6 = false;
        this.server = null;
        this.sockets = [];
        // @ts-expect-error We're overwriting a parent method with a different signature
        this.emit = emit;
        this.broadcast = broadcast;
        this.config = config;
        this.path = path;
        this.port = port;
        this.log = log;
        this.publish = super.emit;
        eventParser = new Parser(this.config);
        this.on("close", serverClosed.bind(this));
    }
    onStart(socket) {
        this.publish("start", socket);
    }
    stop() {
        this.server.close();
    }
    start() {
        if (!this.path) {
            this.log("Socket Server Path not specified, refusing to start");
            return;
        }
        if (this.config.unlink) {
            fs__default["default"].unlink(this.path, startServer.bind(this));
        }
        else {
            startServer.bind(this)();
        }
    }
}
function emit(socket, type, data) {
    this.log("dispatching event to socket", " : ", type, data);
    let message = new Message_1();
    message.type = type;
    message.data = data;
    if (this.config.rawBuffer) {
        this.log(this.config.encoding);
        message = Buffer.from(type, this.config.encoding);
    }
    else {
        message = eventParser.format(message);
    }
    if (this.udp4 || this.udp6) {
        if (!socket.address || !socket.port) {
            this.log("Attempting to emit to a single UDP socket without supplying socket address or port. Redispatching event as broadcast to all connected sockets");
            this.broadcast(type, data);
            return;
        }
        this.server.write(message, socket);
        return;
    }
    socket.write(message);
}
function broadcast(type, data) {
    this.log("broadcasting event to all known sockets listening to ", this.path, " : ", this.port ? this.port : "", type, data);
    let message = new Message_1();
    message.type = type;
    message.data = data;
    if (this.config.rawBuffer) {
        message = Buffer.from(type, this.config.encoding);
    }
    else {
        message = eventParser.format(message);
    }
    if (this.udp4 || this.udp6) {
        for (let i = 1, count = this.sockets.length; i < count; i++) {
            this.server.write(message, this.sockets[i]);
        }
    }
    else {
        for (let i = 0, count = this.sockets.length; i < count; i++) {
            this.sockets[i].write(message);
        }
    }
}
function serverClosed() {
    for (let i = 0, count = this.sockets.length; i < count; i++) {
        let socket = this.sockets[i];
        let destroyedSocketId = false;
        if (socket) {
            if (socket.readable) {
                continue;
            }
        }
        if (socket.id) {
            destroyedSocketId = socket.id;
        }
        this.log("socket disconnected", destroyedSocketId.toString());
        if (socket && socket.destroy) {
            socket.destroy();
        }
        this.sockets.splice(i, 1);
        this.publish("socket.disconnected", socket, destroyedSocketId);
        return;
    }
}
function gotData(socket, data, UDPSocket) {
    let sock = this.udp4 || this.udp6 ? UDPSocket : socket;
    if (this.config.rawBuffer) {
        data = Buffer.from(data, this.config.encoding);
        this.publish("data", data, sock);
        return;
    }
    if (!sock.ipcBuffer) {
        sock.ipcBuffer = "";
    }
    data = sock.ipcBuffer += data;
    if (data.slice(-1) != eventParser.delimiter ||
        data.indexOf(eventParser.delimiter) == -1) {
        this.log("Messages are large, You may want to consider smaller messages.");
        return;
    }
    sock.ipcBuffer = "";
    data = eventParser.parse(data);
    while (data.length > 0) {
        let message = new Message_1();
        message.load(data.shift());
        // Only set the sock id if it is specified.
        if (message.data && message.data.id) {
            sock.id = message.data.id;
        }
        this.log("received event of : ", message.type, message.data);
        this.publish(message.type, message.data, sock);
    }
}
function socketClosed(socket) {
    this.publish("close", socket);
}
function serverCreated(socket) {
    this.sockets.push(socket);
    if (socket.setEncoding) {
        socket.setEncoding(this.config.encoding);
    }
    this.log("## socket connection to server detected ##");
    socket.on("close", socketClosed.bind(this));
    socket.on("error", function (err) {
        this.log("server socket error", err);
        this.publish("error", err);
    }.bind(this));
    socket.on("data", gotData.bind(this, socket));
    socket.on("message", function (msg, rinfo) {
        if (!rinfo) {
            return;
        }
        this.log("Received UDP message from ", rinfo.address, rinfo.port);
        let data;
        if (this.config.rawSocket) {
            data = Buffer.from(msg, this.config.encoding);
        }
        else {
            data = msg.toString();
        }
        socket.emit("data", data, rinfo);
    }.bind(this));
    this.publish("connect", socket);
    if (this.config.rawBuffer) {
        return;
    }
}
function startServer() {
    this.log("starting server on ", this.path, this.port ? `:${this.port}` : "");
    if (!this.udp4 && !this.udp6) {
        this.log("starting TLS server", this.config.tls);
        if (!this.config.tls) {
            this.server = net__default["default"].createServer(serverCreated.bind(this));
        }
        else {
            startTLSServer.bind(this)();
        }
    }
    else {
        this.server = dgram__default["default"].createSocket(this.udp4 ? "udp4" : "udp6");
        this.server.write = UDPWrite.bind(this);
        this.server.on("listening", function UDPServerStarted() {
            serverCreated.bind(this)(this.server);
        }.bind(this));
    }
    this.server.on("error", function (err) {
        this.log("server error", err);
        this.publish("error", err);
    }.bind(this));
    this.server.maxConnections = this.config.maxConnections;
    if (!this.port) {
        this.log("starting server as", "Unix || Windows Socket");
        if (process.platform === "win32") {
            this.path = this.path.replace(/^\//, "");
            this.path = this.path.replace(/\//g, "-");
            this.path = `\\\\.\\pipe\\${this.path}`;
        }
        this.server.listen({
            path: this.path,
            readableAll: this.config.readableAll,
            writableAll: this.config.writableAll,
        }, this.onStart.bind(this));
        return;
    }
    if (!this.udp4 && !this.udp6) {
        this.log("starting server as", this.config.tls ? "TLS" : "TCP");
        this.server.listen(this.port, this.path, this.onStart.bind(this));
        return;
    }
    this.log("starting server as", this.udp4 ? "udp4" : "udp6");
    this.server.bind(this.port, this.path);
    this.onStart({
        address: this.path,
        port: this.port,
    });
}
function startTLSServer() {
    this.log("starting TLS server", this.config.tls);
    if (this.config.tls.private) {
        this.config.tls.key = fs__default["default"].readFileSync(this.config.tls.private);
    }
    else {
        this.config.tls.key = fs__default["default"].readFileSync(`${__dirname}/../local-node-ipc-certs/private/server.key`);
    }
    if (this.config.tls.public) {
        this.config.tls.cert = fs__default["default"].readFileSync(this.config.tls.public);
    }
    else {
        this.config.tls.cert = fs__default["default"].readFileSync(`${__dirname}/../local-node-ipc-certs/server.pub`);
    }
    if (this.config.tls.dhparam) {
        this.config.tls.dhparam = fs__default["default"].readFileSync(this.config.tls.dhparam);
    }
    if (this.config.tls.trustedConnections) {
        if (typeof this.config.tls.trustedConnections === "string") {
            this.config.tls.trustedConnections = [this.config.tls.trustedConnections];
        }
        this.config.tls.ca = [];
        for (let i = 0; i < this.config.tls.trustedConnections.length; i++) {
            this.config.tls.ca.push(fs__default["default"].readFileSync(this.config.tls.trustedConnections[i]));
        }
    }
    this.server = tls__default["default"].createServer(this.config.tls, serverCreated.bind(this));
}
function UDPWrite(message, socket) {
    let data = Buffer.from(message, this.config.encoding);
    this.server.send(data, 0, data.length, socket.port, socket.address, function (err, bytes) {
        if (err) {
            this.log("error writing data to socket", err);
            this.publish("error", function (err) {
                this.publish("error", err);
            });
        }
    });
}

class IPC {
    constructor() {
        //public members
        this.config = new Defaults();
        this.of = {};
        this.server = false;
    }
    //protected methods
    get connectTo() {
        return connect;
    }
    get connectToNet() {
        return connectNet;
    }
    get disconnect() {
        return disconnect;
    }
    get serve() {
        return serve;
    }
    get serveNet() {
        return serveNet;
    }
    get log() {
        return log;
    }
}
function log(...args) {
    if (this.config.silent) {
        return;
    }
    for (let i = 0, count = args.length; i < count; i++) {
        if (typeof args[i] != "object") {
            continue;
        }
        args[i] = util__default["default"].inspect(args[i], {
            depth: this.config.logDepth,
            colors: this.config.logInColor,
        });
    }
    this.config.logger(args.join(" "));
}
function disconnect(id) {
    if (!this.of[id]) {
        return;
    }
    this.of[id].explicitlyDisconnected = true;
    this.of[id].off("*", "*");
    if (this.of[id].socket) {
        if (this.of[id].socket.destroy) {
            this.of[id].socket.destroy();
        }
    }
    delete this.of[id];
}
function serve(path, callback) {
    if (typeof path == "function") {
        callback = path;
        path = false;
    }
    if (!path) {
        this.log("Server path not specified, so defaulting to", "ipc.config.socketRoot + ipc.config.appspace + ipc.config.id", this.config.socketRoot + this.config.appspace + this.config.id);
        path = this.config.socketRoot + this.config.appspace + this.config.id;
    }
    if (!callback) {
        callback = emptyCallback;
    }
    this.server = new Server(path, this.config, log);
    this.server.on("start", callback);
}
function emptyCallback() {
    //Do Nothing
}
function serveNet(host, port, UDPType, callback) {
    if (typeof host == "number") {
        callback = UDPType;
        UDPType = port;
        port = host;
        host = false;
    }
    if (typeof host == "function") {
        callback = host;
        UDPType = false;
        host = false;
        port = false;
    }
    if (!host) {
        this.log("Server host not specified, so defaulting to", "ipc.config.networkHost", this.config.networkHost);
        host = this.config.networkHost;
    }
    if (host.toLowerCase() == "udp4" || host.toLowerCase() == "udp6") {
        callback = port;
        UDPType = host.toLowerCase();
        port = false;
        host = this.config.networkHost;
    }
    if (typeof port == "string") {
        callback = UDPType;
        UDPType = port;
        port = false;
    }
    if (typeof port == "function") {
        callback = port;
        UDPType = false;
        port = false;
    }
    if (!port) {
        this.log("Server port not specified, so defaulting to", "ipc.config.networkPort", this.config.networkPort);
        port = this.config.networkPort;
    }
    if (typeof UDPType == "function") {
        callback = UDPType;
        UDPType = false;
    }
    if (!callback) {
        callback = emptyCallback;
    }
    this.server = new Server(host, this.config, log, port);
    if (UDPType) {
        this.server[UDPType] = true;
        if (UDPType === "udp4" && host === "::1") {
            // bind udp4 socket to an ipv4 address
            this.server.path = "127.0.0.1";
        }
    }
    this.server.on("start", callback);
}
function connect(id, path, callback) {
    if (typeof path == "function") {
        callback = path;
        path = false;
    }
    if (!callback) {
        callback = emptyCallback;
    }
    if (!id) {
        this.log("Service id required", "Requested service connection without specifying service id. Aborting connection attempt");
        return;
    }
    if (!path) {
        this.log("Service path not specified, so defaulting to", "ipc.config.socketRoot + ipc.config.appspace + id", (this.config.socketRoot + this.config.appspace + id).data);
        path = this.config.socketRoot + this.config.appspace + id;
    }
    if (this.of[id]) {
        if (!this.of[id].socket.destroyed) {
            this.log("Already Connected to", id, "- So executing success without connection");
            callback();
            return;
        }
        this.of[id].socket.destroy();
    }
    this.of[id] = new Client(this.config, this.log);
    this.of[id].id = id;
    this.of[id].socket ? (this.of[id].socket.id = id) : null;
    this.of[id].path = path;
    this.of[id].connect();
    callback(this);
}
function connectNet(id, host, port, callback) {
    if (!id) {
        this.log("Service id required", "Requested service connection without specifying service id. Aborting connection attempt");
        return;
    }
    if (typeof host == "number") {
        callback = port;
        port = host;
        host = false;
    }
    if (typeof host == "function") {
        callback = host;
        host = false;
        port = false;
    }
    if (!host) {
        this.log("Server host not specified, so defaulting to", "ipc.config.networkHost", this.config.networkHost);
        host = this.config.networkHost;
    }
    if (typeof port == "function") {
        callback = port;
        port = false;
    }
    if (!port) {
        this.log("Server port not specified, so defaulting to", "ipc.config.networkPort", this.config.networkPort);
        port = this.config.networkPort;
    }
    if (typeof callback == "string") {
        // @ts-expect-error TODO: Actually fix this
        UDPType = callback;
        callback = false;
    }
    if (!callback) {
        callback = emptyCallback;
    }
    if (this.of[id]) {
        if (!this.of[id].socket.destroyed) {
            this.log("Already Connected to", id, "- So executing success without connection");
            callback();
            return;
        }
        this.of[id].socket.destroy();
    }
    this.of[id] = new Client(this.config, this.log);
    this.of[id].id = id;
    this.of[id].socket ? (this.of[id].socket.id = id) : null;
    this.of[id].path = host;
    this.of[id].port = port;
    this.of[id].connect();
    callback(this);
}

class IPCModule extends IPC {
    constructor() {
        super();
        this.IPC = IPC;
    }
}
const singleton = new IPCModule();

exports.IPCModule = IPCModule;
exports["default"] = singleton;
