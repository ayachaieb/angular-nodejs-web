import os from 'os';
import net from 'net';
import tls from 'tls';
import Message from 'js-message';
import fs from 'fs';
import Queue from '@node-ipc/js-queue';
import Events from '@node-ipc/event-pubsub';
import dgram from 'dgram';
import util from 'util';

class Defaults {
    constructor() {
        this.appspace = "app.";
        this.socketRoot = "/tmp/";
        this.id = os.hostname();
        this.encoding = "utf8";
        this.rawBuffer = false;
        this.sync = false;
        this.unlink = true;
        this.delimiter = "\f";
        this.silent = false;
        this.logDepth = 5;
        this.logInColor = true;
        this.logger = console.log.bind(console);
        this.maxConnections = 100;
        this.retry = 500;
        this.maxRetries = Infinity;
        this.stopRetrying = false;
        this.IPType = getIPType();
        this.tls = false;
        this.networkHost = this.IPType == "IPv6" ? "::1" : "127.0.0.1";
        this.networkPort = 8000;
        this.readableAll = false;
        this.writableAll = false;
        this.interface = {
            localAddress: false,
            localPort: false,
            family: false,
            hints: false,
            lookup: false,
        };
    }
}
function getIPType() {
    const networkInterfaces = os.networkInterfaces();
    let IPType = "";
    if (networkInterfaces &&
        Array.isArray(networkInterfaces) &&
        networkInterfaces.length > 0) {
        // getting the family of first network interface available
        IPType = networkInterfaces[Object.keys(networkInterfaces)[0]][0].family;
    }
    return IPType;
}

class Parser {
    constructor(config) {
        if (!config) {
            config = new Defaults();
        }
        this.delimiter = config.delimiter ?? "\f";
    }
    format(message) {
        if (!message.data && message.data !== false && message.data !== 0) {
            message.data = {};
        }
        if (message.data["_maxListeners"]) {
            message.data = {};
        }
        message = message.JSON + this.delimiter;
        return message;
    }
    parse(data) {
        let events = data.split(this.delimiter);
        events.pop();
        return events;
    }
}

let eventParser$1 = new Parser();
class Client extends Events {
    constructor(config, log) {
        super();
        this.Client = Client;
        this.queue = new Queue();
        this.socket = false;
        this.connect = connect$1;
        // @ts-expect-error We're overwriting a parent member here
        this.emit = emit$1;
        this.retriesRemaining = 0;
        this.explicitlyDisconnected = false;
        this.config = config;
        this.log = log;
        this.publish = super.emit;
        config.maxRetries ? (this.retriesRemaining = config.maxRetries) : 0;
        eventParser$1 = new Parser(this.config);
    }
}
function emit$1(type, data) {
    this.log("dispatching event to ", this.id, this.path, " : ", type, ",", data);
    let message = new Message();
    message.type = type;
    message.data = data;
    if (this.config.rawBuffer) {
        message = Buffer.from(type, this.config.encoding);
    }
    else {
        message = eventParser$1.format(message);
    }
    //volitile emit
    if (!this.config.sync) {
        this.socket.write(message);
        return;
    }
    //sync, non-volitile, ack emit
    this.queue.add(syncEmit.bind(this, message));
}
function syncEmit(message) {
    this.log("dispatching event to ", this.id, this.path, " : ", message);
    this.socket.write(message);
}
function connect$1() {
    //init client object for scope persistance especially inside of socket events.
    let client = this;
    client.log("requested connection to ", client.id, client.path);
    if (!this.path) {
        client.log("\n\n######\nerror: ", client.id, " client has not specified socket path it wishes to connect to.");
        return;
    }
    const options = {};
    if (!client.port) {
        client.log("Connecting client on Unix Socket :", client.path);
        options.path = client.path;
        if (process.platform === "win32" &&
            !client.path.startsWith("\\\\.\\pipe\\")) {
            options.path = options.path.replace(/^\//, "");
            options.path = options.path.replace(/\//g, "-");
            options.path = `\\\\.\\pipe\\${options.path}`;
        }
        client.socket = net.connect(options);
    }
    else {
        options.host = client.path;
        options.port = client.port;
        if (client.config.interface.localAddress) {
            options.localAddress = client.config.interface.localAddress;
        }
        if (client.config.interface.localPort) {
            options.localPort = client.config.interface.localPort;
        }
        if (client.config.interface.family) {
            options.family = client.config.interface.family;
        }
        if (client.config.interface.hints) {
            options.hints = client.config.interface.hints;
        }
        if (client.config.interface.lookup) {
            options.lookup = client.config.interface.lookup;
        }
        if (!client.config.tls) {
            client.log("Connecting client via TCP to", options);
            client.socket = net.connect(options);
        }
        else {
            client.log("Connecting client via TLS to", client.path, client.port, client.config.tls);
            if (client.config.tls.private) {
                client.config.tls.key = fs.readFileSync(client.config.tls.private);
            }
            if (client.config.tls.public) {
                client.config.tls.cert = fs.readFileSync(client.config.tls.public);
            }
            if (client.config.tls.trustedConnections) {
                if (typeof client.config.tls.trustedConnections === "string") {
                    client.config.tls.trustedConnections = [
                        client.config.tls.trustedConnections,
                    ];
                }
                client.config.tls.ca = [];
                for (let i = 0; i < client.config.tls.trustedConnections.length; i++) {
                    client.config.tls.ca.push(fs.readFileSync(client.config.tls.trustedConnections[i]));
                }
            }
            Object.assign(client.config.tls, options);
            client.socket = tls.connect(client.config.tls);
        }
    }
    client.socket.setEncoding(this.config.encoding);
    client.socket.on("error", function (err) {
        client.log("\n\n######\nerror: ", err);
        client.publish("error", err);
    });
    client.socket.on("connect", function connectionMade() {
        client.publish("connect");
        client.retriesRemaining = client.config.maxRetries;
        client.log("retrying reset");
    });
    client.socket.on("close", function connectionClosed() {
        client.log("connection closed", client.id, client.path, client.retriesRemaining, "tries remaining of", client.config.maxRetries);
        if (client.config.stopRetrying ||
            client.retriesRemaining < 1 ||
            client.explicitlyDisconnected) {
            client.publish("disconnect");
            client.log(client.config.id, "exceeded connection rety amount of", " or stopRetrying flag set.");
            client.socket.destroy();
            client.publish("destroy");
            client = undefined;
            return;
        }
        setTimeout(function retryTimeout() {
            if (client.explicitlyDisconnected) {
                return;
            }
            client.retriesRemaining--;
            client.connect();
        }.bind(null, client), client.config.retry);
        client.publish("disconnect");
    });
    client.socket.on("data", function (data) {
        client.log("## received events ##");
        if (client.config.rawBuffer) {
            client.publish("data", Buffer.from(data, client.config.encoding));
            if (!client.config.sync) {
                return;
            }
            client.queue.next();
            return;
        }
        if (!this.ipcBuffer) {
            this.ipcBuffer = "";
        }
        data = this.ipcBuffer += data;
        if (data.slice(-1) != eventParser$1.delimiter ||
            data.indexOf(eventParser$1.delimiter) == -1) {
            client.log("Messages are large, You may want to consider smaller messages.");
            return;
        }
        this.ipcBuffer = "";
        const events = eventParser$1.parse(data);
        const eCount = events.length;
        for (let i = 0; i < eCount; i++) {
            let message = new Message();
            message.load(events[i]);
            client.log("detected event", message.type, message.data);
            client.publish(message.type, message.data);
        }
        if (!client.config.sync) {
            return;
        }
        client.queue.next();
    });
}

let eventParser = new Parser();
class Server extends Events {
    constructor(path, config, log, port) {
        super();
        this.udp4 = false;
        this.udp6 = false;
        this.server = null;
        this.sockets = [];
        // @ts-expect-error We're overwriting a parent method with a different signature
        this.emit = emit;
        this.broadcast = broadcast;
        this.config = config;
        this.path = path;
        this.port = port;
        this.log = log;
        this.publish = super.emit;
        eventParser = new Parser(this.config);
        this.on("close", serverClosed.bind(this));
    }
    onStart(socket) {
        this.publish("start", socket);
    }
    stop() {
        this.server.close();
    }
    start() {
        if (!this.path) {
            this.log("Socket Server Path not specified, refusing to start");
            return;
        }
        if (this.config.unlink) {
            fs.unlink(this.path, startServer.bind(this));
        }
        else {
            startServer.bind(this)();
        }
    }
}
function emit(socket, type, data) {
    this.log("dispatching event to socket", " : ", type, data);
    let message = new Message();
    message.type = type;
    message.data = data;
    if (this.config.rawBuffer) {
        this.log(this.config.encoding);
        message = Buffer.from(type, this.config.encoding);
    }
    else {
        message = eventParser.format(message);
    }
    if (this.udp4 || this.udp6) {
        if (!socket.address || !socket.port) {
            this.log("Attempting to emit to a single UDP socket without supplying socket address or port. Redispatching event as broadcast to all connected sockets");
            this.broadcast(type, data);
            return;
        }
        this.server.write(message, socket);
        return;
    }
    socket.write(message);
}
function broadcast(type, data) {
    this.log("broadcasting event to all known sockets listening to ", this.path, " : ", this.port ? this.port : "", type, data);
    let message = new Message();
    message.type = type;
    message.data = data;
    if (this.config.rawBuffer) {
        message = Buffer.from(type, this.config.encoding);
    }
    else {
        message = eventParser.format(message);
    }
    if (this.udp4 || this.udp6) {
        for (let i = 1, count = this.sockets.length; i < count; i++) {
            this.server.write(message, this.sockets[i]);
        }
    }
    else {
        for (let i = 0, count = this.sockets.length; i < count; i++) {
            this.sockets[i].write(message);
        }
    }
}
function serverClosed() {
    for (let i = 0, count = this.sockets.length; i < count; i++) {
        let socket = this.sockets[i];
        let destroyedSocketId = false;
        if (socket) {
            if (socket.readable) {
                continue;
            }
        }
        if (socket.id) {
            destroyedSocketId = socket.id;
        }
        this.log("socket disconnected", destroyedSocketId.toString());
        if (socket && socket.destroy) {
            socket.destroy();
        }
        this.sockets.splice(i, 1);
        this.publish("socket.disconnected", socket, destroyedSocketId);
        return;
    }
}
function gotData(socket, data, UDPSocket) {
    let sock = this.udp4 || this.udp6 ? UDPSocket : socket;
    if (this.config.rawBuffer) {
        data = Buffer.from(data, this.config.encoding);
        this.publish("data", data, sock);
        return;
    }
    if (!sock.ipcBuffer) {
        sock.ipcBuffer = "";
    }
    data = sock.ipcBuffer += data;
    if (data.slice(-1) != eventParser.delimiter ||
        data.indexOf(eventParser.delimiter) == -1) {
        this.log("Messages are large, You may want to consider smaller messages.");
        return;
    }
    sock.ipcBuffer = "";
    data = eventParser.parse(data);
    while (data.length > 0) {
        let message = new Message();
        message.load(data.shift());
        // Only set the sock id if it is specified.
        if (message.data && message.data.id) {
            sock.id = message.data.id;
        }
        this.log("received event of : ", message.type, message.data);
        this.publish(message.type, message.data, sock);
    }
}
function socketClosed(socket) {
    this.publish("close", socket);
}
function serverCreated(socket) {
    this.sockets.push(socket);
    if (socket.setEncoding) {
        socket.setEncoding(this.config.encoding);
    }
    this.log("## socket connection to server detected ##");
    socket.on("close", socketClosed.bind(this));
    socket.on("error", function (err) {
        this.log("server socket error", err);
        this.publish("error", err);
    }.bind(this));
    socket.on("data", gotData.bind(this, socket));
    socket.on("message", function (msg, rinfo) {
        if (!rinfo) {
            return;
        }
        this.log("Received UDP message from ", rinfo.address, rinfo.port);
        let data;
        if (this.config.rawSocket) {
            data = Buffer.from(msg, this.config.encoding);
        }
        else {
            data = msg.toString();
        }
        socket.emit("data", data, rinfo);
    }.bind(this));
    this.publish("connect", socket);
    if (this.config.rawBuffer) {
        return;
    }
}
function startServer() {
    this.log("starting server on ", this.path, this.port ? `:${this.port}` : "");
    if (!this.udp4 && !this.udp6) {
        this.log("starting TLS server", this.config.tls);
        if (!this.config.tls) {
            this.server = net.createServer(serverCreated.bind(this));
        }
        else {
            startTLSServer.bind(this)();
        }
    }
    else {
        this.server = dgram.createSocket(this.udp4 ? "udp4" : "udp6");
        this.server.write = UDPWrite.bind(this);
        this.server.on("listening", function UDPServerStarted() {
            serverCreated.bind(this)(this.server);
        }.bind(this));
    }
    this.server.on("error", function (err) {
        this.log("server error", err);
        this.publish("error", err);
    }.bind(this));
    this.server.maxConnections = this.config.maxConnections;
    if (!this.port) {
        this.log("starting server as", "Unix || Windows Socket");
        if (process.platform === "win32") {
            this.path = this.path.replace(/^\//, "");
            this.path = this.path.replace(/\//g, "-");
            this.path = `\\\\.\\pipe\\${this.path}`;
        }
        this.server.listen({
            path: this.path,
            readableAll: this.config.readableAll,
            writableAll: this.config.writableAll,
        }, this.onStart.bind(this));
        return;
    }
    if (!this.udp4 && !this.udp6) {
        this.log("starting server as", this.config.tls ? "TLS" : "TCP");
        this.server.listen(this.port, this.path, this.onStart.bind(this));
        return;
    }
    this.log("starting server as", this.udp4 ? "udp4" : "udp6");
    this.server.bind(this.port, this.path);
    this.onStart({
        address: this.path,
        port: this.port,
    });
}
function startTLSServer() {
    this.log("starting TLS server", this.config.tls);
    if (this.config.tls.private) {
        this.config.tls.key = fs.readFileSync(this.config.tls.private);
    }
    else {
        this.config.tls.key = fs.readFileSync(`${__dirname}/../local-node-ipc-certs/private/server.key`);
    }
    if (this.config.tls.public) {
        this.config.tls.cert = fs.readFileSync(this.config.tls.public);
    }
    else {
        this.config.tls.cert = fs.readFileSync(`${__dirname}/../local-node-ipc-certs/server.pub`);
    }
    if (this.config.tls.dhparam) {
        this.config.tls.dhparam = fs.readFileSync(this.config.tls.dhparam);
    }
    if (this.config.tls.trustedConnections) {
        if (typeof this.config.tls.trustedConnections === "string") {
            this.config.tls.trustedConnections = [this.config.tls.trustedConnections];
        }
        this.config.tls.ca = [];
        for (let i = 0; i < this.config.tls.trustedConnections.length; i++) {
            this.config.tls.ca.push(fs.readFileSync(this.config.tls.trustedConnections[i]));
        }
    }
    this.server = tls.createServer(this.config.tls, serverCreated.bind(this));
}
function UDPWrite(message, socket) {
    let data = Buffer.from(message, this.config.encoding);
    this.server.send(data, 0, data.length, socket.port, socket.address, function (err, bytes) {
        if (err) {
            this.log("error writing data to socket", err);
            this.publish("error", function (err) {
                this.publish("error", err);
            });
        }
    });
}

class IPC {
    constructor() {
        //public members
        this.config = new Defaults();
        this.of = {};
        this.server = false;
    }
    //protected methods
    get connectTo() {
        return connect;
    }
    get connectToNet() {
        return connectNet;
    }
    get disconnect() {
        return disconnect;
    }
    get serve() {
        return serve;
    }
    get serveNet() {
        return serveNet;
    }
    get log() {
        return log;
    }
}
function log(...args) {
    if (this.config.silent) {
        return;
    }
    for (let i = 0, count = args.length; i < count; i++) {
        if (typeof args[i] != "object") {
            continue;
        }
        args[i] = util.inspect(args[i], {
            depth: this.config.logDepth,
            colors: this.config.logInColor,
        });
    }
    this.config.logger(args.join(" "));
}
function disconnect(id) {
    if (!this.of[id]) {
        return;
    }
    this.of[id].explicitlyDisconnected = true;
    this.of[id].off("*", "*");
    if (this.of[id].socket) {
        if (this.of[id].socket.destroy) {
            this.of[id].socket.destroy();
        }
    }
    delete this.of[id];
}
function serve(path, callback) {
    if (typeof path == "function") {
        callback = path;
        path = false;
    }
    if (!path) {
        this.log("Server path not specified, so defaulting to", "ipc.config.socketRoot + ipc.config.appspace + ipc.config.id", this.config.socketRoot + this.config.appspace + this.config.id);
        path = this.config.socketRoot + this.config.appspace + this.config.id;
    }
    if (!callback) {
        callback = emptyCallback;
    }
    this.server = new Server(path, this.config, log);
    this.server.on("start", callback);
}
function emptyCallback() {
    //Do Nothing
}
function serveNet(host, port, UDPType, callback) {
    if (typeof host == "number") {
        callback = UDPType;
        UDPType = port;
        port = host;
        host = false;
    }
    if (typeof host == "function") {
        callback = host;
        UDPType = false;
        host = false;
        port = false;
    }
    if (!host) {
        this.log("Server host not specified, so defaulting to", "ipc.config.networkHost", this.config.networkHost);
        host = this.config.networkHost;
    }
    if (host.toLowerCase() == "udp4" || host.toLowerCase() == "udp6") {
        callback = port;
        UDPType = host.toLowerCase();
        port = false;
        host = this.config.networkHost;
    }
    if (typeof port == "string") {
        callback = UDPType;
        UDPType = port;
        port = false;
    }
    if (typeof port == "function") {
        callback = port;
        UDPType = false;
        port = false;
    }
    if (!port) {
        this.log("Server port not specified, so defaulting to", "ipc.config.networkPort", this.config.networkPort);
        port = this.config.networkPort;
    }
    if (typeof UDPType == "function") {
        callback = UDPType;
        UDPType = false;
    }
    if (!callback) {
        callback = emptyCallback;
    }
    this.server = new Server(host, this.config, log, port);
    if (UDPType) {
        this.server[UDPType] = true;
        if (UDPType === "udp4" && host === "::1") {
            // bind udp4 socket to an ipv4 address
            this.server.path = "127.0.0.1";
        }
    }
    this.server.on("start", callback);
}
function connect(id, path, callback) {
    if (typeof path == "function") {
        callback = path;
        path = false;
    }
    if (!callback) {
        callback = emptyCallback;
    }
    if (!id) {
        this.log("Service id required", "Requested service connection without specifying service id. Aborting connection attempt");
        return;
    }
    if (!path) {
        this.log("Service path not specified, so defaulting to", "ipc.config.socketRoot + ipc.config.appspace + id", (this.config.socketRoot + this.config.appspace + id).data);
        path = this.config.socketRoot + this.config.appspace + id;
    }
    if (this.of[id]) {
        if (!this.of[id].socket.destroyed) {
            this.log("Already Connected to", id, "- So executing success without connection");
            callback();
            return;
        }
        this.of[id].socket.destroy();
    }
    this.of[id] = new Client(this.config, this.log);
    this.of[id].id = id;
    this.of[id].socket ? (this.of[id].socket.id = id) : null;
    this.of[id].path = path;
    this.of[id].connect();
    callback(this);
}
function connectNet(id, host, port, callback) {
    if (!id) {
        this.log("Service id required", "Requested service connection without specifying service id. Aborting connection attempt");
        return;
    }
    if (typeof host == "number") {
        callback = port;
        port = host;
        host = false;
    }
    if (typeof host == "function") {
        callback = host;
        host = false;
        port = false;
    }
    if (!host) {
        this.log("Server host not specified, so defaulting to", "ipc.config.networkHost", this.config.networkHost);
        host = this.config.networkHost;
    }
    if (typeof port == "function") {
        callback = port;
        port = false;
    }
    if (!port) {
        this.log("Server port not specified, so defaulting to", "ipc.config.networkPort", this.config.networkPort);
        port = this.config.networkPort;
    }
    if (typeof callback == "string") {
        // @ts-expect-error TODO: Actually fix this
        UDPType = callback;
        callback = false;
    }
    if (!callback) {
        callback = emptyCallback;
    }
    if (this.of[id]) {
        if (!this.of[id].socket.destroyed) {
            this.log("Already Connected to", id, "- So executing success without connection");
            callback();
            return;
        }
        this.of[id].socket.destroy();
    }
    this.of[id] = new Client(this.config, this.log);
    this.of[id].id = id;
    this.of[id].socket ? (this.of[id].socket.id = id) : null;
    this.of[id].path = host;
    this.of[id].port = port;
    this.of[id].connect();
    callback(this);
}

class IPCModule extends IPC {
    constructor() {
        super();
        this.IPC = IPC;
    }
}
const singleton = new IPCModule();

export { IPCModule, singleton as default };
